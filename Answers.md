תשובת לשאלות עיוניות  : 

1 Networking: 
שאלה 1:  
מה ההבדל בין URLSession ל-Alamofire ?מתי תשתמש בכל אחד מהם? 
תשובה: 
URLSession הוא הכלי הבסיסי של IOS לקריאות רשת (קריאת לצד שרת וכו) הוא נותן שליטה מלאה על התהליך אבל דורש הרבה קוד (boilerplate) לעומתו Alamofire היא ספרייה שמקצרת את העבודה  ,מקלה על JSON parsing וnetworking אבל נותנת פחות שליטה על הפרטים הקטנים 
אז  בURLSession אשתמש כאשר אצטרך שליטה מלאה על כל קריאות הרשת  
וב Alamofire כאשר ארצה לכתוב פחות ,לטפל מהר ב‑networking ו‑JSON parsing,ובפרוייקטים מורכבים עם הרבה קריאות API  
 

שאלה 2: 

 איך היית מטפל בשגיאות רשת במקרים של חיבור אינטרנט לא יציב? 

תשובה: 

במקרה של חיבור אינטרנט לא יציב אני אשתמש בNWPathMonitor (ספרייה חדשה שבאה להחליף את Reachability) על מנת לבדוק חיבור לאינטרנט בזמן אמת ,בנוסף אני אוסיף גלגל טעינה +alert שיציג שאין חיבור לאינטרנט ,מעבר לזה אני אשמור את הנתונים בקאש וכאשר אין אינטרנט אני אציג למשתמש את הנתונים האחרונים שנשמרו ,במידה והאינטרנט חזר אני אוסיף Retry אוטומטי שיעלה את הנתונים מהשרת(אוסיף גם כפתור רענן לטעינת הנתונים מחדש). 

 

Handling Data 2: 
שאלה 1: 
מדוע כדאי להשתמש ב-CoreData לאחסון נתונים במקום UserDefaults? 

תשובה : 
 

אוקיי  שתיהן מערכות של IOS לשמירת נתונים (בדומה לJson)  

userDefulte : 

היא מערכת קטנה לשמירה על נתונים (עוזר לנתונים הראשוניים שעולים עם האפליקציה)  

CoreData : 

זה מערכת לשמירה על נתונים יותר  גדולים ובעזרתה אפשר לבצע חיפוש מיון  סינון 

 ב‑UserDefaults  

אין אפשרות כזו אתה צריך לטעון הכל לזיכרון ולעבור על זה ידני) 

 בנוסף המערכת coreData 

 מביאה מבנה מסודר לשמירה על הנתונים(Entities, Attributes, Relationships). 

לעומת 

UserDefaults = Key-Value  

פשוט, פחות מסודר. 

שאלה 2:	
 כיצד תנהל נתונים שהגיעו מה-API כדי לשמור על ביצועים גבוהים?	 
תשובה:
כדי לשמור על ביצועים גבוהים אני קודם כל אשמור את הנתונים מקומית (caching)
 ואשתמש בCoreData כדי שהאפליקציה לא תצטרך לשלוף נתונים מהשרת כל פעם וזה יחסוך זמן ורשת 
וגם אני אבדוק לפני העלאה האם הנתונים האלה קיימים כבר במידה וכן אני לא יעלה אותם.

בנוסף אשתמש בAlamofire כדי לבצע טעינה אסינכרונית  ומהירה ואני גם אבצע קריאות לAPI בעזרת PAgeination( וככה אני לא אמשוך את כל הנתונים בבת אחת אלה אחלק אותם לדפים לפי מה שהמשתמש יצטרך לקבל כל פעם).
 :Architectural Patterns .3
שאלה 1:
 מדוע כדאי להשתמש ב-MVVM בפרויקטים מורכבים?
תשובה:
כדאי להשתמש בMVVM בפרוייקטים מורכבים קודם כל בגלל ההפרדה המלאה של הUI מהלוגיקה והנתונים  בנוסף קל יותר לתחזק את האפליקציה כאשר היא מחולקת (כל מפתח אחראי על חלק מסוים ואם משהו לא עובד יותר קל לזהות למה ומאיפה) וגם קל יותר להבין איך האפליקציה עובדת ולנטר שגיאות 
שאלה 2:
 איך היית מפריד בין שכבות הקוד כך שהלוגיקה העסקית לא תהיה תלויה בתצוגה?
תשובה:
אני אשתמש בMVVM כדי להפריד את הUI מהלוגיקה והנתונים , אעביר את הנתונים עם callbacks וככה הmodel לא יכיר את הUI והמודל יעקוב ויעדכן  אחרי הנתונים ,והשינויים בלוגיקה או בנתונים לא ישפיעו בכלל על הUI
Offline Mode
שאלה 1:
איך היית מוודא שהאפליקציה פועלת במצב לא מקוון בצורה מיטבית?
תשובה:
כדי שהאפליקציה תעבוד במצב offline בצורה טובה אני אשמור את הנתונים האחרונים בCoreData אבדוק את החיבור בזמן אמת עם NWPathMonitor אציג UI מותאם למצב ללא אינטרנט 
(הודעת אזהרה למשתמש, גלגל טעינה בעת ניסיון לשלוף נתונים, והצגת הנתונים האחרונים מה‑Cache )
ואדאג לבצע Retry אוטומטי בנוסף לריענון ידני כאשר יש אינטרנט.
שאלה 2:
כיצד תעדכן נתונים שנשמרו במכשיר כאשר המשתמש חוזר למצב מקוון?
כאשר המשתמש חוזר למצב מקוון אני אבדוק את החיבור בזמן אמת עם NWPathMonitor, אבצע Retry אוטומטי לקריאות ה‑API החסרות, אעדכן את הנתונים ב‑CoreData ואעדכן את ה‑UI כדי להציג למשתמש את המידע המעודכן,גם אוסיף כפתור רענון ידני לטעינת הנתונים מחדש.

